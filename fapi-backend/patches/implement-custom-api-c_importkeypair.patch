From 76f75c7d948370dce884046600e936dc6af79857 Mon Sep 17 00:00:00 2001
From: "wenxin.leong" <wenxin.leong@infineon.com>
Date: Mon, 19 Jul 2021 09:14:44 +0100
Subject: [PATCH] implement custom api C_ImportKeyPair

- implement C_ImportKeyPair to import TPM persistent key
- do not perform tpm_flushcontext if TPM key is found persistent
- do not perform tpm_loadobj() if key is persistent
- add an option to specific the persistent key auth value
---
 lib/tpm2-pkcs11.def   |   1 +
 lib/tpm2-pkcs11.map   |   1 +
 src/lib/attrs.c       |   2 +
 src/lib/attrs.h       |   2 +
 src/lib/key.c         | 187 ++++++++++++++++++++++++++++++++++++++++++
 src/lib/key.h         |  14 ++++
 src/lib/session_ctx.c |  19 ++++-
 src/lib/token.c       |  45 ++++++++--
 src/lib/tpm.c         | 178 ++++++++++++++++++++++++++++++++++++++++
 src/lib/tpm.h         |  20 +++++
 src/pkcs11.c          |   4 +
 src/pkcs11.h          |  12 +++
 12 files changed, 475 insertions(+), 10 deletions(-)

diff --git a/lib/tpm2-pkcs11.def b/lib/tpm2-pkcs11.def
index 30c1d43..f447ece 100644
--- a/lib/tpm2-pkcs11.def
+++ b/lib/tpm2-pkcs11.def
@@ -60,6 +60,7 @@ EXPORTS
   C_DecryptVerifyUpdate
   C_GenerateKey
   C_GenerateKeyPair
+  C_ImportKeyPair
   C_WrapKey
   C_UnwrapKey
   C_DeriveKey
diff --git a/lib/tpm2-pkcs11.map b/lib/tpm2-pkcs11.map
index f16cc5f..b846cfd 100644
--- a/lib/tpm2-pkcs11.map
+++ b/lib/tpm2-pkcs11.map
@@ -60,6 +60,7 @@
     C_DecryptVerifyUpdate;
     C_GenerateKey;
     C_GenerateKeyPair;
+    C_ImportKeyPair;
     C_WrapKey;
     C_UnwrapKey;
     C_DeriveKey;
diff --git a/src/lib/attrs.c b/src/lib/attrs.c
index 2cd1734..6a94900 100644
--- a/src/lib/attrs.c
+++ b/src/lib/attrs.c
@@ -170,6 +170,8 @@ static attr_handler2 attr_handlers[] = {
     ADD_ATTR_HANDLER(CKA_TPM2_PUB_BLOB, TYPE_BYTE_HEX_STR),
     ADD_ATTR_HANDLER(CKA_TPM2_PRIV_BLOB, TYPE_BYTE_HEX_STR),
     ADD_ATTR_HANDLER(CKA_TPM2_ENC_BLOB, TYPE_BYTE_HEX_STR),
+    ADD_ATTR_HANDLER(CKA_TPM2_IS_PERSISTENT_KEY, TYPE_BYTE_BOOL),
+    ADD_ATTR_HANDLER(CKA_TPM2_PERSISTENT_KEY_HANDLE, TYPE_BYTE_INT),
 };
 
 static attr_handler2 default_handler = { .memtype = 0 };
diff --git a/src/lib/attrs.h b/src/lib/attrs.h
index 8b4146a..a5baacb 100644
--- a/src/lib/attrs.h
+++ b/src/lib/attrs.h
@@ -15,6 +15,8 @@
 #define CKA_TPM2_PUB_BLOB    (CKA_VENDOR_DEFINED|CKA_VENDOR_TPM2_DEFINED|0x2UL)
 #define CKA_TPM2_PRIV_BLOB   (CKA_VENDOR_DEFINED|CKA_VENDOR_TPM2_DEFINED|0x3UL)
 #define CKA_TPM2_ENC_BLOB    (CKA_VENDOR_DEFINED|CKA_VENDOR_TPM2_DEFINED|0x4UL)
+#define CKA_TPM2_IS_PERSISTENT_KEY      (CKA_VENDOR_DEFINED|CKA_VENDOR_TPM2_DEFINED|0x5UL)
+#define CKA_TPM2_PERSISTENT_KEY_HANDLE    (CKA_VENDOR_DEFINED|CKA_VENDOR_TPM2_DEFINED|0x6UL)
 
 /* Invalid values for error detection */
 #define CK_OBJECT_CLASS_BAD (~(CK_OBJECT_CLASS)0)
diff --git a/src/lib/key.c b/src/lib/key.c
index a3bfa8e..67741be 100644
--- a/src/lib/key.c
+++ b/src/lib/key.c
@@ -327,3 +327,190 @@ out:
 
     return rv;
 }
+
+CK_RV key_import (
+        session_ctx *ctx,
+
+        CK_MECHANISM_PTR mechanism,
+
+        CK_ATTRIBUTE_PTR public_key_template,
+        CK_ULONG public_key_attribute_count,
+
+        CK_ATTRIBUTE_PTR private_key_template,
+        CK_ULONG private_key_attribute_count,
+
+        CK_ULONG persistent_key_handle,
+        CK_CHAR_PTR auth_value) {
+
+    ((void) persistent_key_handle);
+
+    CK_RV rv = CKR_GENERAL_ERROR;
+
+    twist newauthhex = NULL;
+    twist newwrapped_auth = NULL;
+
+    attr_list *pubkey_templ_w_types = NULL;
+    attr_list *privkey_templ_w_types = NULL;
+
+    tobject *new_private_tobj = NULL;
+    tobject *new_public_tobj = NULL;
+
+    tpm_object_data objdata = { 0 };
+
+    token *tok = session_ctx_get_token(ctx);
+    assert(tok);
+
+    /*
+     * Attribute arrays specified by the user don't have the type
+     * information, but are safe for basic sanity checks (for now).
+     */
+    rv = check_common_attrs(
+            private_key_template,
+            private_key_attribute_count);
+    if (rv != CKR_OK) {
+        LOGE("Failed checking private attrs");
+        goto out;
+    }
+
+    rv = check_common_attrs(
+            public_key_template,
+            public_key_attribute_count);
+    if (rv != CKR_OK) {
+        LOGE("Failed checking public attrs");
+        goto out;
+    }
+
+    check_specific_attrs(mechanism->mechanism,
+            public_key_template, public_key_attribute_count,
+            private_key_template, private_key_attribute_count);
+
+    /*
+     * Following functions demand to know about the type tagging,
+     * so "typeify" the user supplied attrs.
+     */
+    bool res = attr_typify(public_key_template, public_key_attribute_count, &pubkey_templ_w_types);
+    if (!res) {
+        LOGE("Failed typifying public attrs");
+        goto out;
+    }
+
+    res = attr_typify(private_key_template, private_key_attribute_count, &privkey_templ_w_types);
+    if (!res) {
+        LOGE("Failed typifying private attrs");
+        goto out;
+    }
+
+    /* re-seat pointers to type safe ones */
+    public_key_template = NULL;
+    private_key_template = NULL;
+
+    new_private_tobj = tobject_new();
+    if (!new_private_tobj) {
+        rv = CKR_HOST_MEMORY;
+        goto out;
+    }
+
+    new_public_tobj = tobject_new();
+    if (!new_public_tobj) {
+        rv = CKR_HOST_MEMORY;
+        goto out;
+    }
+
+    newauthhex = twist_new((const char *)auth_value);
+
+    rv = utils_ctx_wrap_objauth(tok->wrappingkey, newauthhex, &newwrapped_auth);
+    if (rv != CKR_OK) {
+        LOGE("Failed to wrap new object auth");
+        goto out;
+    }
+
+    rv = tpm2_import_persistent_key(
+            tok->tctx,
+            tok->pobject.handle,
+            tok->pobject.objauth,
+            newauthhex,
+            mechanism,
+            pubkey_templ_w_types,
+            privkey_templ_w_types,
+            persistent_key_handle,
+            &objdata);
+    if (rv != CKR_OK) {
+        LOGE("Failed to generate key");
+        goto out;
+    }
+
+    /* set the tpm object handles */
+    tobject_set_handle(new_private_tobj, objdata.privhandle);
+    tobject_set_handle(new_public_tobj, objdata.pubhandle);
+
+    new_public_tobj->attrs = pubkey_templ_w_types;
+    new_private_tobj->attrs = privkey_templ_w_types;
+
+    /* make it clear that tobj now owns these */
+    pubkey_templ_w_types = privkey_templ_w_types = NULL;
+
+    /*
+     * objects have default required attributes, add them if not present.
+     */
+    rv = attr_add_missing_attrs(&new_public_tobj->attrs, &new_private_tobj->attrs,
+            objdata.attrs, mechanism->mechanism);
+    if (rv != CKR_OK) {
+        LOGE("Failed to add missing rsa attrs");
+        goto out;
+    }
+
+    /* populate blob data */
+    rv = tobject_set_blob_data(new_private_tobj, objdata.pubblob, objdata.privblob);
+    if (rv != CKR_OK) {
+        goto out;
+    }
+
+    rv = tobject_set_blob_data(new_public_tobj, objdata.pubblob, NULL);
+    if (rv != CKR_OK) {
+        goto out;
+    }
+
+    /* populate auth data, public objects do not need an auth */
+    rv = tobject_set_auth(new_private_tobj, newauthhex, newwrapped_auth);
+    if (rv != CKR_OK) {
+        goto out;
+    }
+
+    rv = backend_add_object(tok, new_public_tobj);
+    if (rv != CKR_OK) {
+        LOGE("Failed to add public object to db");
+        goto out;
+    }
+
+    rv = backend_add_object(tok, new_private_tobj);
+    if (rv != CKR_OK) {
+        LOGE("Failed to add public object to db");
+        goto out;
+    }
+
+    rv = token_add_tobject(tok, new_public_tobj);
+    if (rv != CKR_OK) {
+        LOGE("Failed to add public object to token");
+        goto out;
+    }
+
+    rv = token_add_tobject(tok, new_private_tobj);
+    if (rv != CKR_OK) {
+        LOGE("Failed to add private object to token");
+        goto out;
+    }
+
+out:
+    tpm_objdata_free(&objdata);
+    twist_free(newauthhex);
+    twist_free(newwrapped_auth);
+    attr_list_free(pubkey_templ_w_types);
+    attr_list_free(privkey_templ_w_types);
+
+    if (rv != CKR_OK) {
+        tobject_free(new_private_tobj);
+        tobject_free(new_public_tobj);
+    }
+
+    return rv;
+}
diff --git a/src/lib/key.h b/src/lib/key.h
index 0ddf806..f14f10d 100644
--- a/src/lib/key.h
+++ b/src/lib/key.h
@@ -22,4 +22,18 @@ CK_RV key_gen (
         CK_OBJECT_HANDLE_PTR public_key,
         CK_OBJECT_HANDLE_PTR private_key);
 
+CK_RV key_import (
+        session_ctx *ctx,
+
+        CK_MECHANISM_PTR mechanism,
+
+        CK_ATTRIBUTE_PTR public_key_template,
+        CK_ULONG public_key_attribute_count,
+
+        CK_ATTRIBUTE_PTR private_key_template,
+        CK_ULONG private_key_attribute_count,
+
+        CK_ULONG persistent_key_handle,
+        CK_CHAR_PTR auth_value);
+
 #endif /* SRC_PKCS11_KEY_H_ */
diff --git a/src/lib/session_ctx.c b/src/lib/session_ctx.c
index d597951..e94a1f2 100644
--- a/src/lib/session_ctx.c
+++ b/src/lib/session_ctx.c
@@ -317,10 +317,23 @@ CK_RV session_ctx_logout(session_ctx *ctx) {
                 attr_pfree_cleanse(a);
             }
 
+            CK_ATTRIBUTE_PTR p = attr_get_attribute_by_type(tobj->attrs, CKA_TPM2_IS_PERSISTENT_KEY);
+            CK_BBOOL is_persistent_key = CK_FALSE;
+            if (p) {
+                CK_RV rv = attr_CK_BBOOL(p, &is_persistent_key);
+                if (rv != CKR_OK) {
+                    LOGE("Error converting attribute CKA_TPM2_IS_PERSISTENT_KEY");
+                    return rv;
+                }
+            }
+
             if (tobj->tpm_handle) {
-                bool result = tpm_flushcontext(tpm, tobj->tpm_handle);
-                assert(result);
-                UNUSED(result);
+                if (is_persistent_key == CK_FALSE) {
+                    bool result = tpm_flushcontext(tpm, tobj->tpm_handle);
+                    assert(result);
+                    UNUSED(result);
+                }
+
                 tobj->tpm_handle = 0;
 
                 /* Clear the unwrapped auth value for tertiary objects */
diff --git a/src/lib/token.c b/src/lib/token.c
index 6d7ebd2..9977c0f 100644
--- a/src/lib/token.c
+++ b/src/lib/token.c
@@ -544,6 +544,16 @@ CK_RV token_load_object(token *tok, CK_OBJECT_HANDLE key, tobject **loaded_tobj)
 
     tobject *tobj = *loaded_tobj;
 
+    CK_ATTRIBUTE_PTR p = attr_get_attribute_by_type(tobj->attrs, CKA_TPM2_IS_PERSISTENT_KEY);
+    CK_BBOOL is_persistent_key = CK_FALSE;
+    if (p) {
+        rv = attr_CK_BBOOL(p, &is_persistent_key);
+        if (rv != CKR_OK) {
+            LOGE("Error converting attribute CKA_TPM2_IS_PERSISTENT_KEY");
+            return rv;
+        }
+    }
+
     rv = tobject_user_increment(tobj);
     if (rv != CKR_OK) {
         return rv;
@@ -579,13 +589,34 @@ CK_RV token_load_object(token *tok, CK_OBJECT_HANDLE key, tobject **loaded_tobj)
         return CKR_OK;
     }
 
-    rv = tpm_loadobj(
-            tpm,
-            tok->pobject.handle, tok->pobject.objauth,
-            tobj->pub, tobj->priv,
-            &tobj->tpm_handle);
-    if (rv != CKR_OK) {
-        return rv;
+    if (is_persistent_key == CK_TRUE) {
+        CK_ATTRIBUTE_PTR p = attr_get_attribute_by_type(tobj->attrs, CKA_TPM2_PERSISTENT_KEY_HANDLE);
+        if (p) {
+            CK_ULONG sys_handle = 0;
+
+            rv = attr_CK_ULONG(p, &sys_handle);
+            if (rv != CKR_OK) {
+                LOGE("Error converting attribute CKA_TPM2_PERSISTENT_KEY_HANDLE");
+                return rv;
+            }
+
+            if (tpm_sys2esys_handle(tpm, (uint32_t)sys_handle, &tobj->tpm_handle) != CKR_OK) {
+                LOGE("Cannot convert TPM persistent key sys_handle to esys_handle");
+                return CKR_TPM2_BAD_PERSISTENT_HANDLE;
+            }
+        } else {
+            LOGE("Cannot find CKA_TPM2_PERSISTENT_KEY_HANDLE");
+            return CKR_TPM2_BAD_PERSISTENT_HANDLE;
+        }
+    } else {
+        rv = tpm_loadobj(
+                tpm,
+                tok->pobject.handle, tok->pobject.objauth,
+                tobj->pub, tobj->priv,
+                &tobj->tpm_handle);
+        if (rv != CKR_OK) {
+            return rv;
+        }
     }
 
     rv = utils_ctx_unwrap_objauth(tok->wrappingkey, tobj->objauth,
diff --git a/src/lib/tpm.c b/src/lib/tpm.c
index 1639df4..c3dc94a 100644
--- a/src/lib/tpm.c
+++ b/src/lib/tpm.c
@@ -3426,6 +3426,163 @@ error:
     return rv;
 }
 
+CK_RV tpm2_import_persistent_key(
+        tpm_ctx *tpm,
+
+        uint32_t parent,
+        twist parentauth,
+
+        twist newauthbin,
+
+        CK_MECHANISM_PTR mechanism,
+
+        attr_list *pubattrs,
+
+        attr_list *privattrs,
+
+        CK_ULONG persistent_key_handle,
+
+        tpm_object_data *objdata) {
+
+#if 1
+    (void) parent;
+    (void) parentauth;
+    (void) newauthbin;
+    (void) pubattrs;
+    (void) privattrs;
+#endif
+
+    twist tmppub = NULL;
+    twist tmppriv = NULL;
+
+    TPM2B_PUBLIC *out_pub = NULL;
+    TPM2B_PRIVATE *out_priv = NULL;
+
+    TPM2B_NAME *name = NULL;
+    TPM2B_NAME *qualified_name = NULL;
+
+    ESYS_TR out_handle = 0;
+
+    CK_RV rv = CKR_GENERAL_ERROR;
+
+    assert(objdata);
+
+    rv = sanity_check_mech(mechanism);
+    if (rv != CKR_OK) {
+        goto error;
+    }
+
+    rv = tpm_sys2esys_handle(tpm, (uint32_t)persistent_key_handle, &out_handle);
+    if (rv != CKR_OK) {
+        goto error;
+    }
+    rv = tpm_readpub(tpm, out_handle, &out_pub, &name, &qualified_name);
+    if (rv != CKR_OK) {
+        goto error;
+    }
+
+    out_priv = calloc(1, sizeof(TPM2B_PRIVATE));
+
+    assert(out_pub);
+    assert(out_priv);
+
+    /* serialize the tpm public private object portions */
+    rv = serialize_pub_priv_blobs(out_pub, out_priv, &tmppub, &tmppriv);
+    if (rv != CKR_OK) {
+        goto error;
+    }
+
+    objdata->attrs = attr_list_new();
+    if (!objdata->attrs) {
+        twist_free(tmppub);
+        twist_free(tmppriv);
+        LOGE("oom");
+        rv = CKR_HOST_MEMORY;
+        goto error;
+    }
+
+    switch(mechanism->mechanism) {
+    case CKM_RSA_PKCS_KEY_PAIR_GEN:
+        rv = tpm_object_data_populate_rsa(out_pub, objdata);
+        break;
+    case CKM_EC_KEY_PAIR_GEN:
+        rv = tpm_object_data_populate_ecc(out_pub, objdata);
+        break;
+    default:
+        LOGE("Impossible keygen type, got: 0x%lx", mechanism->mechanism);
+        rv = CKR_MECHANISM_INVALID;
+        assert(rv == CKR_OK);
+        goto error;
+    }
+
+    if (rv != CKR_OK) {
+        goto error;
+    }
+
+    /* everything common*/
+    TPMA_OBJECT objattrs = out_pub->publicArea.objectAttributes;
+
+    CK_BBOOL extractable = !!!(objattrs & (TPMA_OBJECT_FIXEDTPM|TPMA_OBJECT_FIXEDPARENT));
+    bool r = attr_list_add_bool(objdata->attrs, CKA_EXTRACTABLE, extractable);
+    goto_error_false(r);
+
+
+    CK_BBOOL sensitive = !extractable;
+    r = attr_list_add_bool(objdata->attrs, CKA_ALWAYS_SENSITIVE, sensitive);
+    goto_error_false(r);
+
+
+    CK_BBOOL never_extractable = !extractable;
+    r = attr_list_add_bool(objdata->attrs, CKA_NEVER_EXTRACTABLE, never_extractable);
+    goto_error_false(r);
+
+    CK_BBOOL local = !!(objattrs & TPMA_OBJECT_SENSITIVEDATAORIGIN);
+    r = attr_list_add_bool(objdata->attrs, CKA_LOCAL, local);
+    goto_error_false(r);
+
+    /* conditional block */
+    CK_BBOOL decrypt = !!(objattrs & TPMA_OBJECT_DECRYPT);
+    r = attr_list_add_bool(objdata->attrs, CKA_DECRYPT, decrypt);
+    goto_error_false(r);
+
+    /* decrypt and verify are the same */
+    r = attr_list_add_bool(objdata->attrs, CKA_VERIFY, decrypt);
+    goto_error_false(r);
+
+    CK_BBOOL sign = !!(objattrs & TPMA_OBJECT_SIGN_ENCRYPT);
+    r = attr_list_add_bool(objdata->attrs, CKA_SIGN, sign);
+    goto_error_false(r);
+
+    /* sign and encrypt are same */
+    r = attr_list_add_bool(objdata->attrs, CKA_ENCRYPT, sign);
+    goto_error_false(r);
+
+    /* is a persistent key */
+    CK_BBOOL isPersistent = CK_TRUE;
+    r = attr_list_add_bool(objdata->attrs, CKA_TPM2_IS_PERSISTENT_KEY, isPersistent);
+    goto_error_false(r);
+
+    /* persistent key handle */
+    r = attr_list_add_int(objdata->attrs, CKA_TPM2_PERSISTENT_KEY_HANDLE, persistent_key_handle);
+    goto_error_false(r);
+
+    objdata->privblob = tmppriv;
+    objdata->pubblob = tmppub;
+    objdata->privhandle = out_handle;
+
+    rv = CKR_OK;
+error:
+
+    Esys_Free(out_pub);
+    Esys_Free(out_priv);
+
+    if (rv != CKR_OK) {
+        tpm_objdata_free(objdata);
+    }
+
+    return rv;
+}
+
 void tpm_objdata_free(tpm_object_data *objdata) {
 
     if (!objdata) {
@@ -4242,3 +4399,24 @@ out:
     return rv;
 }
 
+CK_RV tpm_sys2esys_handle(tpm_ctx *tpm, uint32_t sys_handle, ESYS_TR *esys_handle) {
+
+    ESYS_TR handle = ESYS_TR_NONE;
+
+    TSS2_RC rval = Esys_TR_FromTPMPublic(
+        tpm->esys_ctx,
+        sys_handle,
+        ESYS_TR_NONE,
+        ESYS_TR_NONE,
+        ESYS_TR_NONE,
+        &handle);
+    if (rval != TSS2_RC_SUCCESS) {
+        LOGE("Esys_TR_FromTPMPublic: %s:", Tss2_RC_Decode(rval));
+        return CKR_GENERAL_ERROR;
+    }
+
+    *esys_handle = handle;
+
+    return CKR_OK;
+}
+
diff --git a/src/lib/tpm.h b/src/lib/tpm.h
index 7dbf816..0f3148b 100644
--- a/src/lib/tpm.h
+++ b/src/lib/tpm.h
@@ -176,6 +176,24 @@ CK_RV tpm2_generate_key(
 
         tpm_object_data *objdata);
 
+CK_RV tpm2_import_persistent_key(
+        tpm_ctx *tpm,
+
+        uint32_t parent,
+        twist parentauth,
+
+        twist newauthbin,
+
+        CK_MECHANISM_PTR mechanism,
+
+        attr_list *pubattrs,
+
+        attr_list *privattrs,
+
+        CK_ULONG persistent_key_handle,
+
+        tpm_object_data *objdata);
+
 CK_RV tpm2_getmechanisms(tpm_ctx *ctx, CK_MECHANISM_TYPE *mechanism_list, CK_ULONG_PTR count);
 
 CK_RV tpm_get_existing_primary(tpm_ctx *tpm, uint32_t *primary_handle, twist *primary_blob);
@@ -188,6 +206,8 @@ CK_RV tpm_create_transient_primary_from_template(tpm_ctx *tpm,
 
 CK_RV tpm_get_pss_sig_state(tpm_ctx *tctx, tobject *tobj, bool *pss_sigs_good);
 
+CK_RV tpm_sys2esys_handle(tpm_ctx *tpm, uint32_t sys_handle, uint32_t *esys_handle);
+
 bool tpm_get_name(tpm_ctx *ctx, uint32_t handle, twist *name);
 
 void tpm_init(void);
diff --git a/src/pkcs11.c b/src/pkcs11.c
index 89d9b86..5c27cd8 100644
--- a/src/pkcs11.c
+++ b/src/pkcs11.c
@@ -615,6 +615,10 @@ CK_RV C_GenerateKeyPair (CK_SESSION_HANDLE session, CK_MECHANISM *mechanism, CK_
     TOKEN_WITH_LOCK_BY_SESSION_USER_RW(key_gen, session, mechanism, public_key_template, public_key_attribute_count, private_key_template, private_key_attribute_count, public_key, private_key);
 }
 
+CK_RV C_ImportKeyPair (CK_SESSION_HANDLE session, CK_MECHANISM *mechanism, CK_ATTRIBUTE *public_key_template, CK_ULONG public_key_attribute_count, CK_ATTRIBUTE *private_key_template, CK_ULONG private_key_attribute_count, CK_ULONG persistent_key_handle, CK_CHAR_PTR auth_value) {
+    TOKEN_WITH_LOCK_BY_SESSION_USER_RW(key_import, session, mechanism, public_key_template, public_key_attribute_count, private_key_template, private_key_attribute_count, persistent_key_handle, auth_value);
+}
+
 CK_RV C_WrapKey (CK_SESSION_HANDLE session, CK_MECHANISM *mechanism, CK_OBJECT_HANDLE wrapping_key, CK_OBJECT_HANDLE key, CK_BYTE_PTR wrapped_key, CK_ULONG_PTR wrapped_key_len) {
     TOKEN_UNSUPPORTED;
 }
diff --git a/src/pkcs11.h b/src/pkcs11.h
index a26f084..69f8d27 100644
--- a/src/pkcs11.h
+++ b/src/pkcs11.h
@@ -1357,6 +1357,16 @@ _CK_DECLARE_FUNCTION (C_GenerateRandom,
 _CK_DECLARE_FUNCTION (C_GetFunctionStatus, (ck_session_handle_t session));
 _CK_DECLARE_FUNCTION (C_CancelFunction, (ck_session_handle_t session));
 
+/* Import persistent key */
+_CK_DECLARE_FUNCTION (C_ImportKeyPair,
+		      (ck_session_handle_t session,
+		       struct ck_mechanism *mechanism,
+		       struct ck_attribute *public_key_template,
+		       unsigned long public_key_attribute_count,
+		       struct ck_attribute *private_key_template,
+		       unsigned long private_key_attribute_count,
+		       unsigned long persistent_key_handle,
+		       unsigned char *auth_value));
 
 struct ck_function_list
 {
@@ -1548,6 +1558,8 @@ struct ck_c_initialize_args
 #define CKR_FUNCTION_REJECTED			(0x200UL)
 #define CKR_VENDOR_DEFINED			((unsigned long) (1UL << 31))
 
+#define CKR_VENDOR_TPM2_DEFINED                 (0x0F000000UL)
+#define CKR_TPM2_BAD_PERSISTENT_HANDLE          (CKR_VENDOR_DEFINED|CKR_VENDOR_TPM2_DEFINED|0x1UL)
 
 #define CKZ_DATA_SPECIFIED			(0x01UL)
 
-- 
2.31.1.windows.1

